{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"WoW Vandhaachu!","text":"<p>This portal is a structured resource to help you learn Power BI, DAX, and core concepts in data analysis and visualization.</p> <p>You will find session notes, pre-read contents, step-by-step tutorials, and other resources that will help you in learning.</p>"},{"location":"index.html#what-you-will-learn","title":"\ud83d\udcda What You Will Learn","text":"<ul> <li>Power BI Basics \u2013 Navigating the interface and understanding key components  </li> <li>Schema Design \u2013 Structuring data models for clarity and performance  </li> <li>Connecting to Data Sources \u2013 Importing data from:  </li> <li>CSV and Excel files  </li> <li>JSON and XML files  </li> <li>SQL Databases  </li> <li>Google Sheets and other cloud sources  </li> <li>Data Modeling \u2013 Building relationships, managing tables, and creating star schemas  </li> <li>DAX Fundamentals \u2013 Writing calculated columns, measures, and using key functions  </li> <li>Data Visualization \u2013 Creating effective reports and dashboards  </li> <li>Security &amp; Access Control \u2013 Managing row-level security and permissions  </li> <li>Power BI Service \u2013 Publishing reports, setting up workspaces, and sharing with others</li> </ul> <p>Hope you will find it useful and enjoy the learning process...</p>"},{"location":"dax.html","title":"The DAX Language","text":"<p>DAX is the language of Power Pivot, Power BI, SSAS Tabular and it is simple to use, but takes effor to understand. The DAX formula resembles Excel formula because it was devleoped along with Power Pivot for Excel. But there are some important difference compared to Excel formulas; which are there is no concept of cells, rows or columns. There are many new functions and frequently new functions are added to this language.</p> <p>DAX is designed for data models and business use cases.</p>"},{"location":"dax.html#functional-language","title":"Functional Language","text":"<p>DAX is a functional language and the execution of any expression flows with function calls. Given belows is an example of a DAX expression:</p> DAX Expression Example<pre><code>FMCG Sales Amount =\n    SUMX (\n        FILTER (\n            Sales,\n            Sales[Category] = \"FMCG\"\n        ),\n        Sales[Quantity] * Sales[Price]\n    )\n</code></pre> <p>This expression first filters the <code>Sales</code> table where the <code>Category</code> field has value <code>FMCG</code>. The result of the <code>FILTER</code> function is a filtered table which is then passed to <code>SUMX</code> and the <code>SUMX</code> function then goes through each row in the filtered table and keeps totalling the result of <code>Quantity * Price</code> and finally returns the result. This result is stored in a measure named <code>FMCG Sales Amount</code></p> <p>This is just an example to demonstrate how DAX, as a functional language, uses pre-built functions to compute results.</p>"},{"location":"dax.html#data-types-in-dax","title":"Data Types in DAX","text":"<p>DAX has a very minimal set of data types.</p> Numeric Data TypesDate &amp; TimeOther Data Types <ul> <li>Integer</li> <li>Decimal</li> <li>Currency</li> <li>TRUE / FALSE (Boolean)</li> </ul> <ul> <li>Date</li> <li>DateTime</li> </ul> <p>Date and DateTime are stored as decimal numbers. Every Date or DateTime value has an integer part and a decimal part. The integer part is a number representing the number of days elapsed since 30th December 1899. The time part is stored as a fraction computed as follows:</p> <ul> <li>1 hour = \\(\\frac{1}{24}\\)</li> <li>1 minute = \\(\\frac{1}{24 \\times 60} = \\frac{1}{1440}\\)</li> <li>1 second = \\(\\frac{1}{24 \\times 60 \\times 60} = \\frac{1}{86400}\\) </li> <li>1 millisecond = \\(\\frac{1}{24 \\times 60 \\times 60 \\times 1000} = \\frac{1}{86400000}\\) </li> </ul> <p>So any \\(Date + 1\\) will be next day. Any \\(Date - 1\\) will be previous day. Adding \\(\\frac{5}{24} + \\frac{30}{1440}\\) will add \\(5.5 \\: hours\\) to the date and so on. This will be very useful in computations dealing with dates and datetimes.</p> <ul> <li>String</li> <li>Binary Objects</li> </ul>"},{"location":"dax.html#dax-syntax","title":"DAX Syntax","text":"<p>When we write DAX code, we will be using table names and column names to perform various computations on them. There is a syntax or format to be followed:</p> <ul> <li>The general format is to use <code>'Table Name'[Column]</code>.</li> <li>If the table name does not have multiple words, we can skip the single quotes and use <code>Table[Column]</code>.</li> <li>If we are writing a DAX formula on the current table, we can skip the table name and use the column name only. DO NOT DO IT though. Reading the code becomes difficult later on.</li> <li>The square brackets around the column names should always be used.</li> </ul>"},{"location":"dax.html#calculated-columns","title":"Calculated Columns","text":"<ul> <li>These are columns added to the tables using DAX</li> <li>The values in the column will be computed row by row.</li> <li>The column <code>Product[Price]</code> means:<ul> <li>The value of the <code>Price</code> column</li> <li>In the <code>Product</code> table.</li> <li>For the current row.</li> <li>Different for each row.</li> </ul> </li> </ul>"},{"location":"dax.html#calculated-columns-and-measures","title":"Calculated Columns and Measures","text":"<ul> <li>Suppose our <code>Sales</code> table have 1000 rows.</li> <li>In each row, there is a <code>Sales[SalesAmount]</code> column and <code>Sales[ProductCost]</code> column.</li> <li>Suppose we want to find the <code>Gross Margin %</code> of all sales (1000 rows)</li> <li>We can add a Calculated Column in the <code>Sales</code> table to compute the <code>Gross Margin</code> for each row as <code>Gross Margin = Sales[SalesAmount] - Sales[ProductCost]</code>. This can be computed for each row. THIS IS OKAY.</li> <li>But if would be WRONG to add a calculated column as <code>Gross Margin % = Sales[Gross Margin] / Sales[SalesAmount]</code> and then sum it up. It won't give the <code>Gross Margin %</code> of total sales obviously.</li> <li>In this case, we need measures.<ul> <li><code>TotalSalesAmount = SUMX(Sales,Sales[SalesAmount])</code></li> <li><code>TotalGrossMargin = SUMX(Sales,Sales[GrossMargin])</code></li> <li><code>Gross Margin % = [TotalGrossMargin] / [TotalSalesAmount]</code> Now the <code>Gross Margin %</code> will be correct. </li> </ul> </li> </ul> <p>The reason is \\(\\sum_{rows=1}^{1000}  \\frac{Margin}{Sales} \\ne \\frac{\\sum Margin}{\\sum Sales}\\)</p>"},{"location":"dax.html#measures","title":"Measures","text":"<ul> <li>Written using DAX</li> <li>Do not work row by row</li> <li>Instead, use tables and aggregators</li> <li>Do not have the \u00abcurrent row\u00bb concept</li> <li>Examples<ul> <li><code>GrossMargin</code> is a calculated column but can be a measure too</li> <li><code>GrossMargin %</code> needs to be a measure</li> </ul> </li> </ul>"},{"location":"dax.html#calculated-columns-vs-measures","title":"Calculated Columns Vs Measures","text":"<ul> <li>Calculated Columns belongs to a TABLE. So we always use table name along with the column name as <code>TableName[ColumnName]</code></li> <li>Measures DO NOT belong to a TABLE. We can move a measure from one table to another. It will be listed under a table only for organization or grouping purpose. When we refer to a measure, avoid using the table name and just refer to it using the measure name in square brackets as <code>[MeasureName]</code></li> <li>Calculated Columns are computed at the time of report refresh or data load. It occupies storage and once it is computed at report refresh time, it does not respond to what we select in filters or slicers. The values don't change.</li> <li>Measures are not stored in the tables and does not occupy any space. It consumes CPU power. When we use measures in our visualizations, depending on the slicers or filters we choose, the values of measures change dynamically based on the FILTER CONTEXT and EVALUATION CONTEXT.</li> <li>Use Measures when you want to compute percentages, ratios, complex aggregations and want the results to be dynamic based on the slicers and filters.</li> </ul>"},{"location":"dax.html#handling-errors","title":"Handling Errors","text":"<ul> <li>An expression like <code>Sales[Amount] / Sales[Quantity]</code> fail if<ul> <li><code>Sales[Quantity]</code> is zero</li> <li><code>Sales[Quantity]</code> is a string and cannot be converted to number.</li> </ul> </li> <li>Cause of errors<ul> <li>Conversion errors</li> <li>Arithmetical operations</li> <li>Empty or missing values</li> </ul> </li> </ul>"},{"location":"dax.html#iserrorexpression","title":"ISERROR(Expression)","text":"<p>The <code>ISERROR()</code> function takes any expression and evaluates it and returns <code>TRUE</code> or <code>FALSE</code> depending on the presence of an error during evaluation.</p> ISERROR Example<pre><code>ISERROR (\n    Sales[GrossMargin] / Sales[Amount]\n)\n</code></pre>"},{"location":"dax.html#iferrorexpressionalternative","title":"IFERROR(Expression,Alternative)","text":"<p>In case of error returns Alternative. Useful to avoid writing expression twice.</p> <p>IF &amp; ISERROR Wrong example<pre><code>IF(\n    ISERROR (\n        Sales[GrossMargin] / Sales[Amount]\n    ),\n    0,\n    Sales[GrossMargin] / Sales[Amount]\n)\n</code></pre> This can be written better as IFERROR example<pre><code>IFERROR (\n    Sales[GrossMargin] / Sales[Amount],\n    0\n)\n</code></pre></p>"},{"location":"dax.html#aggregate-functions","title":"Aggregate Functions","text":"<ul> <li>Useful to aggregate values<ul> <li><code>SUM(Table[Column])</code></li> <li><code>AVERAGE(Table[Column])</code></li> <li><code>MIN(Table[Column])</code></li> <li><code>MAX(Table[Column])</code></li> </ul> </li> <li>Work only on numeric columns</li> <li>Aggregate only one column<ul> <li><code>SUM(Sales[Amount])</code></li> <li><code>SUM(Sales[Quantity] * Sales[Rate])</code> This won't work.</li> </ul> </li> </ul>"},{"location":"dax.html#the-x-aggregation-functions","title":"The X Aggregation Functions","text":"<ul> <li>Iterators: useful to aggregate formulas<ul> <li>SUMX</li> <li>AVERAGEX</li> <li>MINX</li> <li>MAXX</li> </ul> </li> <li>Iterate over the table and evaluate the expression for each row</li> <li>Always receive two parameters<ul> <li>Table to iterate</li> <li>Formula to evaluate for each row</li> </ul> </li> </ul> <p>SUMX Example<pre><code>SalesAmount = SUMX(\n    Sales,\n    Sales[Price] * Sales[Quantity]\n)\n</code></pre> Other functions like <code>AVERAGEX</code>, <code>MINX</code> and <code>MAXX</code> work the same way.</p>"},{"location":"dax.html#counting-values","title":"Counting Values","text":"<ul> <li>Useful to count values<ul> <li><code>COUNT</code> (only numeric columns)</li> <li><code>COUNTA</code> (counts anything except blanks)</li> <li><code>COUNTBLANK</code> (counts blanks)</li> <li><code>COUNTROWS</code> (counts rows in a table)</li> <li><code>DISTINCTCOUNT</code> (performs distinct count)</li> </ul> </li> <li>The X aggregation versions.<ul> <li><code>COUNTX</code></li> <li><code>COUNTAX</code></li> <li>Works similar to other X aggregators like <code>SUMX</code>, <code>AVERAGEX</code> etc...</li> </ul> </li> </ul> COUNTROWS Example<pre><code>COUNTROWS(Sales) = \n    COUNTA(Sales[SaleID]) + \n    COUNTBLANK(Sales[SaleID])\n</code></pre>"},{"location":"dax.html#logical-functions","title":"Logical Functions","text":"<p>Provides boolean logic.</p> <ul> <li><code>AND</code> or <code>&amp;&amp;</code></li> <li><code>OR</code> or <code>||</code></li> <li><code>NOT</code></li> <li><code>IF</code></li> <li><code>IFERROR</code></li> </ul> Logical Functions Example<pre><code>Yield % = \n    IF(\n        AND(\n            Sales[Category] = \"Soft\",\n            Sales[PitstopGroup] = \"NanoPod\"\n        ),\n        0.90,\n        0\n    )\n</code></pre> <p>OR</p> Logical Functions Example<pre><code>Yield % = \n    IF(\n        Sales[Category] = \"Soft\" &amp;&amp;\n        Sales[PitstopGroup] = \"NanoPod\",\n        0.90,\n        0\n    )\n</code></pre>"},{"location":"dax.html#the-switch-function","title":"The SWITCH Function","text":"<p>Makes it easier to perform nested IF Internally, it is converted into a set of nested IF.</p> <p>Nested IF Example<pre><code>Discount =\nIF (\n    Sales[Category] = \"M\",\n    IF (\n        Sales[Quantity] &gt; 15,\n        0.10,\n        IF ( Sales[Quantity] &gt; 10, 0.08, IF ( Sales[Quantity] &gt; 5, 0.06, 0 ) )\n    ),\n    IF (\n        Sales[Category] = \"B\",\n        IF (\n            Sales[Quantity] &gt; 15,\n            0.15,\n            IF ( Sales[Quantity] &gt; 10, 0.10, IF ( Sales[Quantity] &gt; 5, 0.05, 0 ) )\n        )\n    )\n)\n</code></pre> This nested IF statement can be written using SWITCH as SWITCH Example<pre><code>Discount = \n    SWITCH(\n        TRUE(),\n        Sales[Category] = \"M\" &amp;&amp; Sales[Quantity] &gt; 15, 0.10,\n        Sales[Category] = \"M\" &amp;&amp; Sales[Quantity] &gt; 10, 0.08,\n        Sales[Category] = \"M\" &amp;&amp; Sales[Quantity] &gt; 5, 0.06,\n        Sales[Category] = \"B\" &amp;&amp; Sales[Quantity] &gt; 15, 0.15,\n        Sales[Category] = \"B\" &amp;&amp; Sales[Quantity] &gt; 10, 0.10,\n        Sales[Category] = \"B\" &amp;&amp; Sales[Quantity] &gt; 5, 0.05,\n        0\n    )\n</code></pre> Another example: SWITCH Another Example<pre><code>TerminalGroup = \n    SWITCH(\n        LEFT(Sales[TerminalID],4),\n        \"PBTN\", \"WoW\",\n        \"PBLD\", \"Training\",\n        \"LTTN\", \"Liquidation\",\n        \"Testing\"\n    )\n</code></pre></p>"},{"location":"dax.html#information-functions","title":"Information Functions","text":"<p>Provide information about expressions or values.</p> <ul> <li>ISBLANK</li> <li>ISNUMBER</li> <li>ISTEXT</li> <li>ISNONTEXT</li> <li>ISERROR</li> </ul>"},{"location":"dax.html#max-and-min","title":"MAX and MIN","text":"MAX &amp; MIN<pre><code>MAX(Sales[Amount])\n// OR\nMAXX(Sales,Sales[Amount])\n// Computes the maximum value in the Amount column of Sales Table\n\nMAX(Sales[Amount],Sales[ListPrice])\n//OR\nIF(Sales[Amount]&gt;Sales[ListPrice],Sales[Amount],Sales[ListPrice])\n// Computes maximum of these two values \n// in each row when used in other expressions.\n</code></pre>"},{"location":"dax.html#mathematical-functions","title":"Mathematical Functions","text":"<ul> <li><code>ABS</code></li> <li><code>EXP</code></li> <li><code>FACT</code></li> <li><code>LN</code></li> <li><code>LOG</code></li> <li><code>LOG10</code></li> <li><code>MOD</code></li> <li><code>PI</code></li> <li><code>POWER</code></li> <li><code>QUOTIENT</code></li> <li><code>SIGN</code></li> <li><code>SQRT</code></li> </ul>"},{"location":"dax.html#the-divide-function","title":"The DIVIDE Function","text":"<p>Divide is useful to avoid using <code>IF</code> inside an expression to check for zero denominators</p> Error Handling using IF<pre><code>IF(\n    Sales[Quantity] &lt;&gt; 0,\n    Sales[Amount] / Sales[Quantity],\n    0\n)\n</code></pre> <p>You can write it better with <code>DIVIDE</code></p> <p>DIVIDE example<pre><code>DIVIDE(Sales[Amount],Sales[Quantity],0)\n</code></pre> This returns <code>0</code> if the division fails.</p>"},{"location":"dax.html#using-variables","title":"Using Variables","text":"<p>Very useful to avoid repeating subexpressions in your code.</p> Repeating Sub Expressions<pre><code>IF(\n    SUM(Sales[Quantity]) &gt; 1000,\n    SUM(Sales[Quantity]) * 0.95,\n    SUM(Sales[Quantity]) * 1.25\n)\n</code></pre> <p>This is inefficient because the SUM formula will have to compute the sum of Quantity field from Sales table three times. We can write it better using variables.</p> <p>Repeating Sub Expressions<pre><code>VAR TotalQuantity = SUM(Sales[Quantity])\nIF(\n    TotalQuantity &gt; 1000,\n    TotalQuantity * 0.95,\n    TotalQuantity * 1.25\n)\n</code></pre> Here it is evaluated only once. Better and faster.</p>"},{"location":"dax.html#rounding-functions","title":"Rounding Functions","text":"<p>Many different rounding functions:</p> <ul> <li><code>FLOOR ( Value, 0.01 )</code></li> <li><code>TRUNC ( Value, 2 )</code></li> <li><code>ROUNDDOWN ( Value, 2 )</code></li> <li><code>MROUND ( Value, 0.01 )</code></li> <li><code>ROUND ( Value, 2 )</code></li> <li><code>CEILING ( Value, 0.01 )</code></li> <li><code>ISO.CEILING ( Value, 0.01 )</code></li> <li><code>ROUNDUP ( Value, 2 )</code></li> <li><code>INT ( Value )</code></li> </ul>"},{"location":"dax.html#text-functions","title":"Text Functions","text":"<p>Let\u2019s assume we have the following sample values: Sample Values<pre><code>Customer[FirstName] = \"John\"\nCustomer[LastName] = \"Doe\"\nCustomer[Code] = \"ABC123\"\nCustomer[Amount] = 12345.678\n</code></pre></p> Sample Values<pre><code>= CONCATENATE(Customer[FirstName], \" \", Customer[LastName]) \n// Result: \"John Doe\"\n\n= CONCATENATEX(VALUES(Customer[City]), Customer[City], \", \")\n// Result: \"Mumbai, Delhi, Chennai\"\n\n= FIND(\"C\", Customer[Code], 1)   \n// Result: 3 (position of \"C\" in \"ABC123\")\n\n= SEARCH(\"c\", Customer[Code], 1)\n// Result: 3 (case-insensitive unlike FIND)\n\n= LEFT(Customer[Code], 3)   \n// Result: \"ABC\"\n\n= RIGHT(Customer[Code], 3)  \n// Result: \"123\"\n\n= MID(Customer[Code], 2, 3)\n// Result: \"BC1\"\n\n= LEN(Customer[Code])\n// Result: 6\n\n= LOWER(Customer[Code])   \n// Result: \"abc123\"\n\n= UPPER(Customer[FirstName])  \n// Result: \"JOHN\"\n\n= TRIM(\"  John  \")  \n// Result: \"John\" (removes extra spaces)\n\n= EXACT(\"John\", \"john\")\n// Result: FALSE (case-sensitive)\n\n= REPLACE(Customer[Code], 4, 3, \"999\")\n// Result: \"ABC999\"\n\n= SUBSTITUTE(\"red,red,blue\", \"red\", \"green\")\n// Result: \"green,green,blue\"\n\n= FIXED(Customer[Amount], 2, TRUE)\n// Result: \"12345.68\"\n\n= FORMAT(Customer[Amount], \"#,##0.00\")\n// Result: \"12,345.68\"\n\n= REPT(\"*\", 5)  \n// Result: \"*****\"\n\n= VALUE(\"123.45\")  \n// Result: 123.45 as number\n</code></pre>"},{"location":"dax.html#date-functions","title":"Date Functions","text":"Date Functions<pre><code>= DATE(2023, 12, 25)   \n// Returns: 25-Dec-2023\n\n= DATEVALUE(\"2023-12-25\")\n// Returns: 25-Dec-2023\n\n= TIME(14, 30, 0)\n// Returns: 2:30:00 PM\n\n= TIMEVALUE(\"14:30:00\")\n// Returns: 2:30:00 PM\n\n= HOUR(Sales[OrderDate])\n// Extracts the hour part (0\u201323)\n\n= MINUTE(Sales[OrderDate])\n// Extracts the minute part (0\u201359)\n\n= SECOND(Sales[OrderDate])\n// Extracts the second part (0\u201359)\n\n= DAY(Sales[OrderDate])\n// Extracts day of the month (1\u201331)\n\n= MONTH(Sales[OrderDate])\n// Extracts month (1\u201312)\n\n= YEAR(Sales[OrderDate])\n// Extracts year (e.g., 2023)\n\n= NOW()\n// Returns current date and time\n\n= TODAY()\n// Returns current date (without time)\n\n= EDATE(Sales[OrderDate], 2)\n// Date after 2 months\n\n= EOMONTH(Sales[OrderDate], 0)\n// End of the current month\n\n= WEEKDAY(Sales[OrderDate], 2)\n// Returns day of week (1=Monday to 7=Sunday)\n\n= WEEKNUM(Sales[OrderDate], 2)\n// Returns week number of the year\n\n= YEARFRAC(DATE(2023,1,1), Sales[OrderDate])\n// Returns fraction of the year completed from Jan 1, 2023 to OrderDate\n</code></pre>"},{"location":"dax.html#relational-functions","title":"Relational Functions","text":""},{"location":"dax.html#related","title":"<code>RELATED</code>","text":"<p>Follows relationships and returns the value of a column.</p> <p>Date Functions<pre><code>bf_ops_user_roster['RosterStatus'] = related(bf_ops_roster['Status'])\n</code></pre> If there is a relationship between user roster and roster, this fetches the roster status from <code>bf_ops_roster</code> into <code>bf_ops_user_roster</code>. This function is written in the table on many-side of the relationship to get the data from one-side. That is for each row, there can be only one row in the relation target.</p>"},{"location":"dax.html#related_table","title":"<code>RELATED_TABLE</code>","text":"<p>Follows relationships and returns the rows that are related to the current row.</p> Date Functions<pre><code>SalesHeader['SKU Count'] = COUNTROWS(RELATEDTABLE(SalesItems))\n</code></pre> <p>For each sales header, there will be multiple rows (one row for each SKU in the invoice) on the sales items table. The related table used on the header table returns all the rows from sales items table that matches the relationship keys.</p> <p>Brief note on function types</p> <p>In DAX, there are two kinds of functions. </p> <ul> <li>Scalar Functions: Functions that return a single value. Like <code>SUMX</code>, <code>MAX</code>, <code>RELATED</code> etc...</li> <li>Table Functions: Functions that return a table. Like <code>ALL</code>, <code>FILTER</code>, <code>RELATEDTABLE</code> etc...</li> </ul>"},{"location":"introduction.html","title":"Introduction","text":""},{"location":"introduction.html#power-bi-datasets","title":"Power BI Datasets","text":"<p>This image shows the flow of data in the context of Power BI. Behind every Power BI Dashboard, there is an underlying dataset. The data from various sources is imported into this dataset as tables. This is the first step. We can import data from hundreds of various datasources and there are connectors available to do this. We don't have to know all of them and instead we use them on need basis depending on our scenario and data source.</p> <p>A collection of tables is not a dataset. It is just a collection of tables. A dataset can be described as a well connected (through relationships) set of tables with additional augmented or custom columns, new derived tables from the source tables, measures, security roles and permissions and so on. The acronym BI in Power BI refers to Business Intelligence. These datasets are powering the Business Intelligence. </p> Measures <p>Measure is the techinical term used in DAX language that refers to formulas that compute results in real-time (not precomputed and stored) and the same measure or the formula will give different results depending on what filters or slicers we select in the report or how we filter data in a Power Pivot.</p> <p>It is \"One Formula - Dynamic results based on the context\"</p>"},{"location":"introduction.html#dax","title":"DAX","text":"<p>DAX, which stands for Data Analysis eXpressions, is the programming language of Microsoft Power BI, Microsoft Analysis Services, and Microsoft Power Pivot for Excel.</p> <p>DAX will be used extensively in the process of dataset creation for adding calculated columns, creating calculated tables, authoring measures, composing queries for API fetches etc...</p> DAX Vs Excel Formulas <p>Though it is a programming language, it is mostly just functions (like excel formulas) and in some cases, we can use variables etc.. For people familiar with Excel or any other spreadsheets, learning DAX will be very easy. But there is one important difference here. Excel formulas work at a cell level. But DAX works at a column level. There is no concept of previous row or next row. </p>"},{"location":"introduction.html#power-bi-desktop","title":"Power BI Desktop","text":"<p>A dataset can be created either using a Power BI Desktop software or directly on Power BI Service (The powerbi.microsoft.com portal). </p> <p>Through these tutorial sessions, we will be using Power BI Desktop software to create datasets and build reports.</p> Reports Vs Dashboards <p>There is a distinct difference between the terms Reports and Dashboards in the context of Power BI. Each report can have only one underlying dataset. A user can create a blank Dashboard and pin or populate this dashboard with visuals from many Reports. We will see more when we use them.</p> <p>Let's get started. The first step is to install the Power BI Desktop software. The link is given below. There will be two installation files. Choose the one that is compatible with your computer's CPU. There are two files available.</p> <ul> <li>PBIDesktopSetup.exe</li> <li>PBIDesktopSetup_x64.exe</li> </ul> <p>For most people who use Intel CPUs, the <code>x64</code> version will be the compatible version. </p> <p>Download Power BI Desktop</p>"},{"location":"introduction.html#additional-software-requirements","title":"Additional Software Requirements","text":"<p>To learn Power BI, you only need \"Power BI Desktop\" software. As you progress and when you want to build real usable reports, you will be fetching data from other sources like MySQL database, Microsoft Fabric Lakehouses, etc... and you will need few more applications that help you do this effortlessly. These are listed below.</p> MySQL Workbench <p>This will be required to connect to our <code>user_app</code>, <code>flow</code> and <code>groot</code> databases and write queries and test them locally. This will also help in querying and exporting data as <code>CSV</code> files that you can import into Power BI to build reports or use in Excel or Google Sheets to perform ad-hoc analysis.</p> <p>Download MySQL Workbench</p> SQL Server Management Studio (SSMS) <p>This will be required to connect to our lakehouses and datawarehouses at Microsoft Fabric and write queries and test them locally. This will also help in querying and exporting data as <code>CSV</code> files that you can import into Power BI to build reports or use in Excel or Google Sheets to perform ad-hoc analysis.</p> <p>Though we can run queries directly in Power BI service using a web browser, there is a limitation that the browser can fetch only up to 10,000 rows. Installing SSMS is necessary to fetch unlimited amount of rows.</p> <p>You can download it from the following webpage. </p> <p>Download SQL Server Management Studio</p> PuTTY <p>PuTTY is an SSH and telnet client. This is needed to connect to the <code>flow</code> MySQL database.</p> <p>Download PuTTY</p>"},{"location":"session_01.html","title":"Building our First Report","text":"<p>We will build a basic report and publish it to Power BI Service. The following are the steps.</p> <ol> <li>Open Power BI Desktop application.</li> <li>Import data from excel sheets as tables.</li> <li>Verify and and correct the data types of table fields as per the nature of data.</li> <li>Load the tables.</li> <li>Build relationship between tables.</li> <li>Set the filter directions correctly in relationships.</li> <li>Add any custom tables if required.</li> <li>Add any custom columns to the tables if requied.</li> <li>Build some measures using DAX.</li> <li>Develop the visualizations.</li> <li>Save and Publish</li> <li>View the report on Power BI Service.</li> </ol> <p>Please download the Excel file given in the following link and we will be using it for this exercise.</p>"}]}